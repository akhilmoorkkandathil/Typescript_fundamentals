This project stands as an in-depth guide to TypeScript, meticulously covering its fundamental basics and progressing to its more advanced concepts. 
Key topics include type annotations, type inference, practical applications of type annotation, union types, handling of "any", "unknown", and "never" types, arrays, and objects fundamentals, challenges to reinforce learning, and functions with their complexities.

What is TypeScript?

By definition, “TypeScript is JavaScript for application-scale development.”

    => TypeScript is a strongly typed, object oriented, compiled language. 
    => It was designed by Anders Hejlsberg (designer of C#) at Microsoft. TypeScript is both a language and a set of tools. 
    => TypeScript is a typed superset of JavaScript compiled to JavaScript. 
    => In other words, TypeScript is JavaScript plus some additional features.


TypeScript and ECMAScript?

    => The ECMAScript specification is a standardized specification of a scripting language. 
    => There are six editions.
    => TypeScript is aligned with the ECMAScript6 specification.
    => TypeScript adopts its basic language features from the ECMAScript5 specification, i.e., the official specification for JavaScript. 
    => TypeScript language features like Modules and class-based orientation are in line with the EcmaScript 6 specification. 
    => Additionally, TypeScript also embraces features like generics and type annotations that aren’t a part of the EcmaScript6 specification.

    Simply, ECMAScript5 + ECMAScript6 + additional features = TypeScript


====== sample code ========
    var message:string = "Hello World" 
    console.log(message)

    On compiling, it will generate following JavaScript code.

    //Generated by typescript 1.8.10
    var message = "Hello World";
    console.log(message);


The TypeScript Compiler?

    => The TypeScript compiler is itself a .ts file compiled down to JavaScript (.js) file. 
    = The TSC (TypeScript Compiler) is a source-to-source compiler (transcompiler / transpiler).


To compile a TypeScript file use the following command on the terminal window.

tsc filename.ts


Identifiers in TypeScript?

    Identifiers are names given to elements in a program like variables, functions etc. 

    The rules for identifiers are −

        => Identifiers can include both, characters and digits. However, the identifier cannot begin with a digit.

        => Identifiers cannot include special symbols except for underscore (_) or a dollar sign ($).

        => Identifiers cannot be keywords.

        => They must be unique.

        => Identifiers are case-sensitive.

        => Identifiers cannot contain spaces.



TypeScript ─ Keywords

Keywords have a special meaning in the context of a language. 

The following table lists some keywords in TypeScript.

break	as	any	switch
case	if	throw	else
var	number	string	get
module	type	instanceof	typeof
public	private	enum	export
finally	for	while	void
null	super	this	new
in	return	true	false
any	extends	static	let
package	implements	interface	function
new	try	yield	const
continue	do	catch


TypeScript and Object Orientation?

TypeScript is Object-Oriented JavaScript. 

    Object − An object is a real time representation of any entity. According to Grady Brooch, every object must have three features −

            State − described by the attributes of an object

            Behavior − describes how the object will act

            Identity − a unique value that distinguishes an object from a set of similar such objects.

    Class − A class in terms of OOP is a blueprint for creating objects. A class encapsulates data for the object.

    Method − Methods facilitate communication between objects.


Exaple:-

class Greeting { 
   greet():void { 
      console.log("Hello World!!!") 
   } 
} 
var obj = new Greeting(); 
obj.greet();

On compiling, it will generate following JavaScript code.

        //Generated by typescript 1.8.10
        var Greeting = (function () {
        function Greeting() {
        }
        Greeting.prototype.greet = function () {
            console.log("Hello World!!!");
        };
            return Greeting;
        }());

        var obj = new Greeting();
        obj.greet()


TypeScript - Types

The Type System represents the different types of values supported by the language. 
The Type System checks the validity of the supplied values, before they are stored or manipulated by the program. 
This ensures that the code behaves as expected. The Type System further allows for richer code hinting and automated documentation too.

1) Any type
The any data type is the super type of all types in TypeScript. 
It denotes a dynamic type. Using the any type is equivalent to opting out of type checking for a variable.

2) Built-in types

The following illustrates all the built-in types in TypeScript −

            => Number	    :- number	Double precision 64-bit floating point values. It can be used to represent both, integers and fractions.
            => String	    :- string	Represents a sequence of Unicode characters
            => Boolean	    :- boolean	Represents logical values, true and false
            => Void	void	:- Used on function return types to represent non-returning functions
            => Null	null	:- Represents an intentional absence of an object value.
            => Undefined	:- undefined	Denotes value given to all uninitialized variables

3) User-defined Types
User-defined types include Enumerations (enums), classes, interfaces, arrays, and tuple.


TypeScript - Variables

A variable, by definition, is “a named space in the memory” that stores values. 
In other words, it acts as a container for values in a program.

Inferred Typing in TypeScript?
    Typescript is strongly typed, this feature is optional. 
    TypeScript also encourages dynamic typing of variables. 
    This means that, TypeScript encourages declaring a variable without a type. 
    In such cases, the compiler will determine the type of the variable on the basis of the value assigned to it. 
    TypeScript will find the first usage of the variable within the code, determine the type to which it has been initially set and then assume the same type for this variable in the rest of your code block.

TypeScript Variable Scope?

The scope of a variable specifies where the variable is defined. 
The availability of a variable within a program is determined by its scope.

TypeScript variables can be of the following scopes −

        Global Scope − Global variables are declared outside the programming constructs. These variables can be accessed from anywhere within your code.

        Class Scope − These variables are also called fields. Fields or class variables are declared within the class but outside the methods. These variables can be accessed using the object of the class. Fields can also be static. Static fields can be accessed using the class name.

        Local Scope − Local variables, as the name suggests, are declared within the constructs like methods, loops etc. Local variables are accessible only within the construct where they are declared.


Example: Variable Scope

var global_num = 12          //global variable 
class Numbers { 
   num_val = 13;             //class variable 
   static sval = 10;         //static field 
   
   storeNum():void { 
      var local_num = 14;    //local variable 
   } 
} 
console.log("Global num: "+global_num)  
console.log(Numbers.sval)   //static variable  
var obj = new Numbers(); 
console.log("Global num: "+obj.num_val) 


What is an Operator?
An operator defines some function that will be performed on the data. The data on which operators work are called operands.

The major operators in TypeScript can be classified as −

        1) Arithmetic operators
        2) Logical operators
        3) Relational operators
        4) Bitwise operators
        5) Assignment operators
        6) Ternary/conditional operator
        7) String operator
        8) Type Operator

1) Arithmetic Operators
    Assume the values in variables a and b are 10 and 5 respectively.

    Examples

    Operator	        Description	                                            Example
    + (Addition)	    returns the sum of the operands	                        a + b is 15
    - (Subtraction)	    returns the difference of the values	                a - b is 5
    * (Multiplication)	returns the product of the values	                        a * b is 50
    / (Division)	    performs division operation and returns the quotient	a / b is 2
    % (Modulus)	        performs division operation and returns the remainder	a % b is 0
    ++ (Increment)	    Increments the value of the variable by one	            a++ is 11
    -- (Decrement)	    Decrements the value of the variable by one	            a-- is 9

2) Logical Operators

Logical Operators are used to combine two or more conditions. Logical operators too return a Boolean value.

Operator	Description	                                                                                Example
&& (And)	The operator returns true only if all the expressions specified return true	                (A > 10 && B > 10) is False
|| (OR)	    The operator returns true if at least one of the expressions specified return true	        (A > 10 || B >10) is True
! (NOT)	T   he operator returns the inverse of the expression’s result. For E.g.: !(>5) returns false	!(A >10 ) is True

3) Relational Operators

Relational Operators test or define the kind of relationship between two entities. Relational operators return a Boolean value, i.e., true/ false.

Operator	Description	                Example
>	        Greater than	            (A > B) is False
<	        Lesser than	                (A < B) is True
>=	        Greater than or equal to	(A >= B) is False
<=	        Lesser than or equal to	    (A <= B) is True
==	        Equality	                (A == B) is false
!=	        Not equal	                (A != B) is True

4) Bitwise Operators

Operator                    Description	                                                                                                                                                                                                                                                                                                        Example
& (Bitwise AND)	            It performs a Boolean AND operation on each bit of its integer arguments.	                                                                                                                                                                                                                                        (A & B) is 2
| (BitWise OR)	            It performs a Boolean OR operation on each bit of its integer arguments.	                                                                                                                                                                                                                                        (A | B) is 3
^ (Bitwise XOR)	            It performs a Boolean exclusive OR operation on each bit of its integer arguments. Exclusive OR means that either operand one is true or operand two is true, but not both.                                                                                                                                        	(A ^ B) is 1
~ (Bitwise Not)	            It is a unary operator and operates by reversing all the bits in the operand.                                                                                                                                                                                                                                       (~B) is -4
<< (Left Shift)	            It moves all the bits in its first operand to the left by the number of places specified in the second operand. New bits are filled with zeros. Shifting a value left by one position is equivalent to multiplying it by 2, shifting two positions is equivalent to multiplying by 4, and so on.                   	(A << 1) is 4
>> (Right Shift)	        Binary Right Shift Operator. The left operand’s value is moved right by the number of bits specified by the right operand.	                                                                                                                                                                                       (A >> 1) is 1
>>> (Right shift with Zero)	This operator is just like the >> operator, except that the bits shifted in on the left are always zero.	                                                                                                                                                                                                         (A >>> 1) is 1


5) Assignment Operators

Operator	                    Description                                                                                             Example
= (Simple Assignment)	        Assigns values from the right side operand to the left side operand	                                    C = A + B will assign the value of A + B into C
+= (Add and Assignment)	        It adds the right operand to the left operand and assigns the result to the left operand.	            C += A is equivalent to C = C + A
-= (Subtract and Assignment)	It subtracts the right operand from the left operand and assigns the result to the left operand.	    C -= A is equivalent to C = C - A
*= (Multiply and Assignment)	It multiplies the right operand with the left operand and assigns the result to the left operand.	    C *= A is equivalent to C = C * A
/= (Divide and Assignment)	    It divides the left operand with the right operand and assigns the result to the left operand.	        C /= A is equivalent to C = C / A

Note − Same logic applies to Bitwise operators, so they will become <<=, >>=, >>=, &=, |= and ^=.

6) Miscellaneous Operators
    The negation operator (-).
    Changes the sign of a value.

    var x:number = 4 
    var y = -x; 
    console.log("value of x: ",x);   //outputs 4 
    console.log("value of y: ",y);   //outputs -4

7) String Operators: Concatenation operator (+)
The + operator when applied to strings appends the second string to the first. 
The following example helps us to understand this concept.
var msg:string = "hello"+"world" 
console.log(msg)

8) Conditional Operator (?)
This operator is used to represent a conditional expression. 
The conditional operator is also sometimes referred to as the ternary operator. 

The syntax is as given below −

  condition ? expr1 : expr2

9) Type Operators

typeof operator
It is a unary operator. This operator returns the data type of the operand. 
Take a look at the following example −

var num = 12 
console.log(typeof num);   //output: number

10) instanceof
This operator can be used to test if an object is of a specified type or not. 



TypeScript - Decision Making?

 Decision-making constructs in TypeScript are classified as follows −

1.	if statement

    An ‘if’ statement consists of a Boolean expression followed by one or more statements.

2.	if...else statement

    An ‘if’ statement can be followed by an optional ‘else’ statement, which executes when the Boolean expression is false.

3.	else…if and nested if statements

    You can use one ‘if’ or ‘else if’ statement inside another ‘if’ or ‘else if’ statement(s).

4.	switch statement

    A ‘switch’ statement allows a variable to be tested against a list of values.


TypeScript - Loops?

1.	for loop
    The for loop is an implementation of a definite loop.

2. while loop
    The while loop executes the instructions each time the condition specified evaluates to true.

3.	do… while
    The do…while loop is similar to the while loop except that the do...while loop doesn’t evaluate the condition for the first time the loop executes.


The break Statement?
The break statement is used to take the control out of a construct. Using break in a loop causes the program to exit the loop.

The continue Statement?
The continue statement skips the subsequent statements in the current iteration and takes the control back to the beginning of the loop. Unlike the break statement, the continue doesn’t exit the loop. It terminates the current iteration and starts the subsequent iteration.

The Infinite Loop
An infinite loop is a loop that runs endlessly. The for loop and the while loop can be used to make an endless loop.


Example:-

for(;;) { 
   console.log(“This is an endless loop”) 
}

while(true) { 
   console.log(“This is an endless loop”) 
}


TypeScript - Functions?

Functions are the building blocks of readable, maintainable, and reusable code. 
A function is a set of statements to perform a specific task. Functions organize the program into logical blocks of code. 
Once defined, functions may be called to access code. This makes the code reusable. 
Moreover, functions make it easy to read and maintain the program’s code.


Funtions & Description

1.	Defining a Function
    A function definition specifies what and how a specific task would be done.

2.	Calling a Function
    A function must be called so as to execute it.

3.	Returning Functions
    Functions may also return value along with control, back to the caller.

4.	Parameterized Function
    Parameters are a mechanism to pass values to functions.

Optional Parameters?
Optional parameters can be used when arguments need not be compulsorily passed for a function’s execution. 
A parameter can be marked optional by appending a question mark to its name. 
The optional parameter should be set as the last argument in a function.

function disp_details(id:number,name:string,mail_id?:string) { 
   console.log("ID:", id); 
   console.log("Name",name); 
   
   if(mail_id!=undefined)  
   console.log("Email Id",mail_id); 
}
disp_details(123,"John");
disp_details(111,"mary","mary@xyz.com");


Rest Parameters?
Rest parameters don’t restrict the number of values that you can pass to a function. 
However, the values passed must all be of the same type. 
In other words, rest parameters act as placeholders for multiple arguments of the same type

function addNumbers(...nums:number[]) {  
   var i;   
   var sum:number = 0; 
   
   for(i = 0;i<nums.length;i++) { 
      sum = sum + nums[i]; 
   } 
   console.log("sum of the numbers",sum) 
} 
addNumbers(1,2,3) 
addNumbers(10,10,10,10,10)

Default Parameters?
Function parameters can also be assigned values by default. However, such parameters can also be explicitly passed values.

function calculate_discount(price:number,rate:number = 0.50) { 
   var discount = price * rate; 
   console.log("Discount Amount: ",discount); 
} 
calculate_discount(1000) 
calculate_discount(1000,0.30)

Anonymous Function?
Functions that are not bound to an identifier (function name) are called as anonymous functions. 
These functions are dynamically declared at runtime. 
Anonymous functions can accept inputs and return outputs, just as standard functions do. 
An anonymous function is usually not accessible after its initial creation.

var msg = function() { 
   return "hello world";  
} 
console.log(msg())


Function Expression and Function Declaration ─ Are they synonymous?

Function expression and function declaration are not synonymous. Unlike a function expression, a function declaration is bound by the function name.

The fundamental difference between the two is that, function declarations are parsed before their execution. On the other hand, function expressions are parsed only when the script engine encounters it during execution.

When the JavaScript parser sees a function in the main code flow, it assumes Function Declaration. When a function comes as a part of a statement, it is a Function Expression.


The Function Constructor?
TypeScript also supports defining a function with the built-in JavaScript constructor called Function ().

var myFunction = new Function("a", "b", "return a * b"); 
var x = myFunction(4, 3); 
console.log(x);


Recursion and TypeScript Functions?
Recursion is a technique for iterating over an operation by having a function call to itself repeatedly until it arrives at a result. 
Recursion is best applied when you need to call the same function repeatedly with different parameters from within a loop.

function factorial(number) {
   if (number <= 0) {         // termination case
      return 1; 
   } else {     
      return (number * factorial(number - 1));     // function invokes itself
   } 
}; 
console.log(factorial(6));      // outputs 720 

Lambda Functions?
Lambda refers to anonymous functions in programming. 
Lambda functions are a concise mechanism to represent anonymous functions. 
These functions are also called as Arrow functions.

Lambda Function - Anatomy

There are 3 parts to a Lambda function −

Parameters − A function may optionally have parameters

The fat arrow notation/lambda notation (=>) − It is also called as the goes to operator

Statements − represent the function’s instruction set. Lambda statement is an anonymous function declaration that points to a block of code. 

var foo = (x:number)=>10 + x 
console.log(foo(100))      //outputs 110 


Function Overloads?
Functions have the capability to operate differently on the basis of the input provided to them. 
In other words, a program can have multiple methods with the same name with different implementation. 
This mechanism is termed as Function Overloading. TypeScript provides support for function overloading.

function disp(s1:string):void; 
function disp(n1:number,s1:string):void; 

function disp(x:any,y?:any):void { 
   console.log(x); 
   console.log(y); 
} 
disp("abc") 
disp(1,"xyz");


TypeScript - Numbers?
TypeScript like JavaScript supports numeric values as Number objects. A number object converts numeric literal to an instance of the number class. The Number class acts as a wrapper and enables manipulation of numeric literals as they were objects.

S.No.	Property & Description
1.	MAX_VALUE

    The largest possible value a number in JavaScript can have 1.7976931348623157E+308.

2.	MIN_VALUE

    The smallest possible value a number in JavaScript can have 5E-324.

3.	NaN

    Equal to a value that is not a number.

4.	NEGATIVE_INFINITY

    A value that is less than MIN_VALUE.

5.	POSITIVE_INFINITY

    A value that is greater than MAX_VALUE.

6.	prototype

    A static property of the Number object. Use the prototype property to assign new properties and methods to the Number object in the current document.

7.	constructor

    Returns the function that created this object's instance. By default, this is the Number object.

Example: prototype

function employee(id:number,name:string) { 
   this.id = id 
   this.name = name 
} 

var emp = new employee(123,"Smith") 
employee.prototype.email = "smith@abc.com" 

console.log("Employee 's Id: "+emp.id) 
console.log("Employee's name: "+emp.name) 
console.log("Employee's Email ID: "+emp.email)


Number Methods?
The Number object contains only the default methods that are a part of every object's definition. Some of the commonly used methods are listed below −

S.No.	Methods & Description
1.	toExponential()
Forces a number to display in exponential notation, even if the number is in the range in which JavaScript normally uses standard notation.

2.	toFixed()
Formats a number with a specific number of digits to the right of the decimal.

3.	toLocaleString()
Returns a string value version of the current number in a format that may vary according to a browser's local settings.

4.	toPrecision()
Defines how many total digits (including digits to the left and right of the decimal) to display of a number. A negative precision will throw an error.

5.	toString()
Returns the string representation of the number's value. The function is passed the radix, an integer between 2 and 36 specifying the base to use for representing numeric values.

6.	valueOf()
Returns the number's primitive value.

TypeScript - Strings?======================
The String object lets you work with a series of characters. It wraps the string primitive data type with a number of helper methods.

S.No.	Property & Description
1.	Constructor
Returns a reference to the String function that created the object.

2.	Length
Returns the length of the string.

3.	Prototype
The prototype property allows you to add properties and methods to an object.

String Methods?==========================
S.No.	Method & Description
1.	charAt()
Returns the character at the specified index.

2.	charCodeAt()
Returns a number indicating the Unicode value of the character at the given index.

3.	concat()
Combines the text of two strings and returns a new string.

4.	indexOf()
Returns the index within the calling String object of the first occurrence of the specified value, or -1 if not found.

5.	lastIndexOf()
Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found.

6.	localeCompare()
Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order.

7.	
match()

Used to match a regular expression against a string.

8.	replace()
Used to find a match between a regular expression and a string, and to replace the matched substring with a new substring.

9.	search()
Executes the search for a match between a regular expression and a specified string.

10.	slice()
Extracts a section of a string and returns a new string.

11.	split()
Splits a String object into an array of strings by separating the string into substrings.

12.	substr()
Returns the characters in a string beginning at the specified location through the specified number of characters.

13.	substring()
Returns the characters in a string between two indexes into the string.

14.	toLocaleLowerCase()
The characters within a string are converted to lower case while respecting the current locale.

15.	toLocaleUpperCase()
The characters within a string are converted to upper case while respecting the current locale.

16.	toLowerCase()
Returns the calling string value converted to lower case.

17.	toString()
Returns a string representing the specified object.

18.	toUpperCase()
Returns the calling string value converted to uppercase.

19.	valueOf()
Returns the primitive value of the specified object.


TypeScript - Arrays? =================

    An array declaration allocates sequential memory blocks.

    Arrays are static. This means that an array once initialized cannot be resized.

    Each memory block represents an array element.

    Array elements are identified by a unique integer called as the subscript / index of the element.

    Like variables, arrays too, should be declared before they are used. Use the var keyword to declare an array.

    Array initialization refers to populating the array elements.

    Array element values can be updated or modified but cannot be deleted.


var alphas:string[]; 
alphas = ["1","2","3","4"] 
console.log(alphas[0]); 
console.log(alphas[1]);

var nums:number[] = [1,2,3,3] 
console.log(nums[0]); 
console.log(nums[1]); 
console.log(nums[2]); 
console.log(nums[3]);


Array Object
An array can also be created using the Array object.

var arr_names:number[] = new Array(4)  

for(var i = 0;i<arr_names.length;i++) { 
   arr_names[i] = i * 2 
   console.log(arr_names[i]) 
}

Example: Array Constructor accepts comma separated values

var names:string[] = new Array("Mary","Tom","Jack","Jill") 

for(var i = 0;i<names.length;i++) { 
   console.log(names[i]) 
}

Array Methods?===================
A list of the methods of the Array object along with their description is given below.

S.No.	Method & Description
1.	concat()
Returns a new array comprised of this array joined with other array(s) and/or value(s).

2.	every()
Returns true if every element in this array satisfies the provided testing function.

3.	filter()
Creates a new array with all of the elements of this array for which the provided filtering function returns true.

4.	forEach()
Calls a function for each element in the array.

5.	indexOf()
Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found.

6.	join()
Joins all elements of an array into a string.

7.	lastIndexOf()
Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found.

8.	map()
Creates a new array with the results of calling a provided function on every element in this array.

9.	pop()
Removes the last element from an array and returns that element.

10.	push()
Adds one or more elements to the end of an array and returns the new length of the array.

11.	reduce()
Apply a function simultaneously against two values of the array (from left-to-right) as to reduce it to a single value.

12.	reduceRight()
Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value.

13.	reverse()
Reverses the order of the elements of an array -- the first becomes the last, and the last becomes the first.

14.	shift()
Removes the first element from an array and returns that element.

15.	slice()
Extracts a section of an array and returns a new array.

16.	some()
Returns true if at least one element in this array satisfies the provided testing function.

17.	sort()
Sorts the elements of an array.

18.	splice()
Adds and/or removes elements from an array.

19.	toString()
Returns a string representing the array and its elements.

20.	unshift()
Adds one or more elements to the front of an array and returns the new length of the array.


Array Destructuring?
Refers to breaking up the structure of an entity. 

var arr:number[] = [12,13] 
var[x,y] = arr 
console.log(x) 
console.log(y)


TypeScript - Tuples?
At times, there might be a need to store a collection of values of varied types. Arrays will not serve this purpose. 
TypeScript gives us a data type called tuple that helps to achieve such a purpose.

var mytuple = [10,"Hello"];

TypeScript - Union? =========
TypeScript 1.4 gives programs the ability to combine one or two types. Union types are a powerful way to express a value that can be one of the several types. 
Two or more data types are combined using the pipe symbol (|) to denote a Union Type. 
In other words, a union type is written as a sequence of types separated by vertical bars.

var val:string|number 
val = 12 
console.log("numeric value of val "+val) 
val = "This is a string" 
console.log("string value of val "+val)


Union Type and function parameter-  Example

function disp(name:string|string[]) { 
   if(typeof name == "string") { 
      console.log(name) 
   } else { 
      var i; 
      
      for(i = 0;i<name.length;i++) { 
         console.log(name[i])
      } 
   } 
} 
disp("mark") 
console.log("Printing names array....") 
disp(["Mark","Tom","Mary","John"])


TypeScript - Interfaces?

The interface keyword is used to declare an interface.

Let’s consider an object −

var person = { 
   FirstName:"Tom", 
   LastName:"Hanks", 
   sayHi: ()=>{ return "Hi"} 
};

To reuse the signature across objects we can define it as an interface.

If we consider the signature of the object, it could be −

{ 
   FirstName:string, 
   LastName:string, 
   sayHi()=>string 
}


Declaring Interfaces

interface IPerson { 
   firstName:string, 
   lastName:string, 
   sayHi: ()=>string 
} 

var customer:IPerson = { 
   firstName:"Tom",
   lastName:"Hanks", 
   sayHi: ():string =>{return "Hi there"} 
} 

var employee:IPerson = { 
   firstName:"Jim",
   lastName:"Blakes", 
   sayHi: ():string =>{return "Hello!!!"} 
} 
  
  Union Type and Interface
The following example shows the use of Union Type and Interface −


interface RunOptions { 
   program:string; 
   commandline:string[]|string|(()=>string); 
} 

//commandline as string 
var options:RunOptions = {program:"test1",commandline:"Hello"}; 
console.log(options.commandline)  

//commandline as a string array 
options = {program:"test1",commandline:["Hello","World"]}; 
console.log(options.commandline[0]); 
console.log(options.commandline[1]);  

//commandline as a function expression 
options = {program:"test1",commandline:()=>{return "**Hello World**";}}; 

var fn:any = options.commandline; 
console.log(fn());

Interfaces and Inheritance?
An interface can be extended by other interfaces. In other words, an interface can inherit from other interface. 
Typescript allows an interface to inherit from multiple interfaces.

interface Person { 
   age:number 
} 

interface Musician extends Person { 
   instrument:string 
} 

var drummer = <Musician>{}; 
drummer.age = 27 
drummer.instrument = "Drums" 
console.log("Age:  "+drummer.age) console.log("Instrument:  "+drummer.instrument)

Example: Multiple Interface Inheritance

interface IParent1 { 
   v1:number 
} 

interface IParent2 { 
   v2:number 
} 

interface Child extends IParent1, IParent2 { } 
var Iobj:Child = { v1:12, v2:23} 
console.log("value 1: "+this.v1+" value 2: "+this.v2)


TypeScript - Classes?
    TypeScript is object oriented JavaScript. 
    TypeScript supports object-oriented programming features like classes, interfaces, etc. 
    A class in terms of OOP is a blueprint for creating objects. A class encapsulates data for the object. 
    Typescript gives built in support for this concept called class. JavaScript ES5 or earlier didn’t support classes. 
    Typescript gets this feature from ES6.

Declaring a class

class Car { 
   //field 
   engine:string; 
 
   //constructor 
   constructor(engine:string) { 
      this.engine = engine 
   }  

   //function 
   disp():void { 
      console.log("Engine is  :   "+this.engine) 
   } 
}

Constructor?
A constructor is a special function of the class that is responsible for initializing the variables of the class. TypeScript defines a constructor using the constructor keyword. A constructor is a function and hence can be parameterized.
The this keyword refers to the current instance of the class. Here, the parameter name and the name of the class’s field are the same. Hence to avoid ambiguity, the class’s field is prefixed with the this keyword.


Creating Instance objects?

To create an instance of the class, use the new keyword followed by the class name.

The new keyword is responsible for instantiation.

The right-hand side of the expression invokes the constructor. The constructor should be passed values if it is parameterized.

var obj = new Car("Engine 1")


Class Inheritance?
    TypeScript supports the concept of Inheritance. Inheritance is the ability of a program to create new classes from an existing class. 
    The class that is extended to create newer classes is called the parent class/super class. 
    The newly created classes are called the child/sub classes.
    A class inherits from another class using the ‘extends’ keyword. 
    Child classes inherit all properties and methods except private members and constructors from the parent class.

class Shape { 
   Area:number 
   
   constructor(a:number) { 
      this.Area = a 
   } 
} 

class Circle extends Shape { 
   disp():void { 
      console.log("Area of the circle:  "+this.Area) 
   } 
}
  
var obj = new Circle(223); 
obj.disp()


Inheritance can be classified as −

Single − Every class can at the most extend from one parent class

Multiple − A class can inherit from multiple classes. TypeScript doesn’t support multiple inheritance.

Multi-level − The following example shows how multi-level inheritance works.

Multi-level-Example
class Root { 
   str:string; 
} 

class Child extends Root {} 
class Leaf extends Child {} //indirectly inherits from Root by virtue of inheritance  

var obj = new Leaf(); 
obj.str ="hello" 
console.log(obj.str)

The class Leaf derives the attributes from Root and Child classes by virtue of multi-level inheritance.

TypeScript ─ Class inheritance and Method Overriding?===========

Method Overriding is a mechanism by which the child class redefines the superclass’s method. 

class PrinterClass { 
   doPrint():void {
      console.log("doPrint() from Parent called…") 
   } 
} 

class StringPrinter extends PrinterClass { 
   doPrint():void { 
      super.doPrint() 
      console.log("doPrint() is printing a string…")
   } 
} 

var obj = new StringPrinter() 
obj.doPrint()

The super keyword is used to refer to the immediate parent of a class. The keyword can be used to refer to the super class version of a variable, property or method.


The static Keyword?
The static keyword can be applied to the data members of a class. 
A static variable retains its values till the program finishes execution. 
Static members are referenced by the class name.

class StaticMem {  
   static num:number; 
   
   static disp():void { 
      console.log("The value of num is"+ StaticMem.num) 
   } 
} 

StaticMem.num = 12     // initialize the static variable 
StaticMem.disp()      // invoke the static method


The instanceof operator?
The instanceof operator returns true if the object belongs to the specified type.

class Person{ } 
var obj = new Person() 
var isPerson = obj instanceof Person; 
console.log(" obj is an instance of Person " + isPerson);


Data Hiding or Encapsulation?

A class can control the visibility of its data members to members of other classes. 
This capability is termed as Data Hiding or Encapsulation.

Object Orientation uses the concept of access modifiers or access specifiers to implement the concept of Encapsulation. 
The access specifiers/modifiers define the visibility of a class’s data members outside its defining class.

The access modifiers supported by TypeScript are −

    S.No.	Access Specifier & Description
    1.	public

    A public data member has universal accessibility. Data members in a class are public by default.

    2.	private

    Private data members are accessible only within the class that defines these members. If an external class member tries to access a private member, the compiler throws an error.

    3.	protected

    A protected data member is accessible by the members within the same class as that of the former and also by the members of the child classes.

class Encapsulate { 
   str:string = "hello" 
   private str2:string = "world" 
}
 
var obj = new Encapsulate() 
console.log(obj.str)     //accessible 
console.log(obj.str2)   //compilation Error as str2 is private

Classes and Interfaces?
Classes can also implement interfaces.

interface ILoan { 
   interest:number 
} 

class AgriLoan implements ILoan { 
   interest:number 
   rebate:number 
   
   constructor(interest:number,rebate:number) { 
      this.interest = interest 
      this.rebate = rebate 
   } 
} 

var obj = new AgriLoan(10,1) 
console.log("Interest is : "+obj.interest+" Rebate is : "+obj.rebate )


TypeScript - Objects?

An object is an instance which contains set of key value pairs. The values can be scalar values or functions or even array of other objects.

var object_name = { 
   key1: “value1”, //scalar value 
   key2: “value”,  
   key3: function() {
      //functions 
   }, 
   key4:[“content1”, “content2”] //collection  
};

Example: Object Literal Notation

var person = { 
   firstname:"Tom", 
   lastname:"Hanks" 
}; 
//access the object values 
console.log(person.firstname) 
console.log(person.lastname)



TypeScript Type Template?

Let’s say you created an object literal in JavaScript as −

var person = { 
   firstname:"Tom", 
   lastname:"Hanks" 
};

In case you want to add some value to an object, JavaScript allows you to make the necessary modification. 
Suppose we need to add a function to the person object later this is the way you can do this.

person.sayHello = function(){ return "hello"}

If you use the same code in Typescript the compiler gives an error. 
This is because in Typescript, concrete objects should have a type template. Objects in Typescript must be an instance of a particular type.

You can solve this by using a method template in declaration.

Example: Typescript Type template
var person = {
   firstName:"Tom", 
   lastName:"Hanks", 
   sayHello:function() {  }  //Type template 
} 
person.sayHello = function() {  
   console.log("hello "+person.firstName)
}  
person.sayHello()

Objects as function parameters

var person = { 
   firstname:"Tom", 
   lastname:"Hanks" 
}; 
var invokeperson = function(obj: { firstname:string, lastname :string }) { 
   console.log("first name :"+obj.firstname) 
   console.log("last name :"+obj.lastname) 
} 
invokeperson(person)

Example: Anonymous Object
var invokeperson = function(obj:{ firstname:string, lastname :string}) { 
   console.log("first name :"+obj.firstname) 
   console.log("last name :"+obj.lastname) 
} 
invokeperson({firstname:"Sachin",lastname:"Tendulkar"});


Duck-typing
In duck-typing, two objects are considered to be of the same type if both share the same set of properties. 
Duck-typing verifies the presence of certain properties in the objects, rather than their actual type, to check their suitability. 
The concept is generally explained by the following phrase −

“When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”

The TypeScript compiler implements the duck-typing system that allows object creation on the fly while keeping type safety. 
The following example shows how we can pass objects that don’t explicitly implement an interface but contain all of the required members to a function.

Example
interface IPoint { 
   x:number 
   y:number 
} 
function addPoints(p1:IPoint,p2:IPoint):IPoint { 
   var x = p1.x + p2.x 
   var y = p1.y + p2.y 
   return {x:x,y:y} 
} 

//Valid 
var newPoint = addPoints({x:3,y:4},{x:5,y:1})  

//Error 
var newPoint2 = addPoints({x:1},{x:4,y:3})
Print Page

completed

